using System.Security.Cryptography;
using System.Text;
using Microsoft.Extensions.Caching.Distributed;

public class ResponseCachingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IDistributedCache _cache;

    public ResponseCachingMiddleware(RequestDelegate next, IDistributedCache cache)
    {
        _next = next;
        _cache = cache;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Only cache GraphQL based requests
        if (!context.Request.Path.StartsWithSegments("/graphql"))
        {
            await _next(context);
            return;
        }

        // Enable buffering to allow us to write to the body twice.
        // Once within the normal flow, then read the body and write it to the cache.
        context.Request.EnableBuffering();
        using var reader = new StreamReader(context.Request.Body, Encoding.UTF8, leaveOpen: true);
        var bodyText = await reader.ReadToEndAsync();
        context.Request.Body.Position = 0;

        var cacheKey = ComputeHash(bodyText);
        var cachedResult = await _cache.GetStringAsync(cacheKey);
        if (cachedResult is not null)
        {
            context.Response.ContentType = "application/json";
            await context.Response.WriteAsync(cachedResult);
            return;
        }

        // Value is not known within the cache, capture the body and write it to the cache.
        var originalBodyStream = context.Response.Body;
        using var bodyStreamToCache = new MemoryStream();
        context.Response.Body = bodyStreamToCache;

        await _next(context);

        bodyStreamToCache.Position = 0;
        var responseText = await new StreamReader(bodyStreamToCache).ReadToEndAsync();

        // Store result with 5 minute time to live.
        // TODO: In the future, we can dynamically store and clear these caches.
        // For example
        await _cache.SetStringAsync(
            cacheKey,
            responseText,
            new DistributedCacheEntryOptions { AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5) });

        // Replay to client
        bodyStreamToCache.Position = 0;
        await bodyStreamToCache.CopyToAsync(originalBodyStream);
        context.Response.Body = originalBodyStream;
    }

    // TODO: check the performance of this hashing with larger queries and if I can't just use the Hash generated by HotChocolate.
    private static string ComputeHash(string input)
    {
        return Convert.ToHexString(SHA256.HashData(Encoding.UTF8.GetBytes(input)));
    }
}
